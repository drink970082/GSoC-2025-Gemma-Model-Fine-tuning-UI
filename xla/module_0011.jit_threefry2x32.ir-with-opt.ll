; ModuleID = 'jit_threefry2x32'
source_filename = "jit_threefry2x32"
target datalayout = "e-p6:32:32-i64:64-i128:128-v16:16-v32:32-n16:32:64"
target triple = "nvptx64-nvidia-cuda"

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define ptx_kernel void @loop_add_fusion_1(ptr noalias readonly align 16 captures(none) dereferenceable(4) %0, ptr noalias readonly align 16 captures(none) dereferenceable(4) %1, ptr noalias readonly align 16 captures(none) dereferenceable(4) %2, ptr noalias readonly align 16 captures(none) dereferenceable(4) %3, ptr noalias writeonly align 128 captures(none) dereferenceable(4) initializes((0, 4)) %4) local_unnamed_addr #0 {
  %6 = addrspacecast ptr %3 to ptr addrspace(1)
  %7 = addrspacecast ptr %2 to ptr addrspace(1)
  %8 = addrspacecast ptr %1 to ptr addrspace(1)
  %9 = addrspacecast ptr %0 to ptr addrspace(1)
  %10 = addrspacecast ptr %4 to ptr addrspace(1)
  %11 = load i32, ptr addrspace(1) %6, align 16, !invariant.load !2
  %12 = load i32, ptr addrspace(1) %7, align 16, !invariant.load !2
  %13 = load i32, ptr addrspace(1) %8, align 16, !invariant.load !2
  %14 = add i32 %13, %12
  %15 = load i32, ptr addrspace(1) %9, align 16, !invariant.load !2
  %16 = add i32 %15, %11
  %17 = tail call i32 @llvm.fshl.i32(i32 %14, i32 %14, i32 13)
  %18 = add i32 %16, %14
  %19 = xor i32 %18, %17
  %20 = tail call i32 @llvm.fshl.i32(i32 %19, i32 %19, i32 15)
  %21 = add i32 %19, %18
  %22 = xor i32 %21, %20
  %23 = add i32 %22, %21
  %24 = tail call i32 @llvm.fshl.i32(i32 %22, i32 %22, i32 26)
  %25 = xor i32 %23, %24
  %26 = tail call i32 @llvm.fshl.i32(i32 %25, i32 %25, i32 6)
  %27 = add i32 %25, %23
  %28 = xor i32 %27, %26
  %29 = xor i32 %13, %15
  %30 = xor i32 %29, 466688986
  %31 = add i32 %30, 1
  %32 = add i32 %31, %28
  %33 = add i32 %27, %13
  %34 = tail call i32 @llvm.fshl.i32(i32 %32, i32 %32, i32 17)
  %35 = add i32 %33, %32
  %36 = xor i32 %35, %34
  %37 = tail call i32 @llvm.fshl.i32(i32 %36, i32 %36, i32 29)
  %38 = add i32 %36, %35
  %39 = xor i32 %38, %37
  %40 = add i32 %39, %38
  %41 = tail call i32 @llvm.fshl.i32(i32 %39, i32 %39, i32 16)
  %42 = xor i32 %40, %41
  %43 = tail call i32 @llvm.fshl.i32(i32 %42, i32 %42, i32 24)
  %44 = add i32 %42, %40
  %45 = xor i32 %44, %43
  %46 = add i32 %15, 2
  %47 = add i32 %46, %45
  %48 = add i32 %44, %30
  %49 = tail call i32 @llvm.fshl.i32(i32 %47, i32 %47, i32 13)
  %50 = add i32 %48, %47
  %51 = xor i32 %50, %49
  %52 = tail call i32 @llvm.fshl.i32(i32 %51, i32 %51, i32 15)
  %53 = add i32 %51, %50
  %54 = xor i32 %53, %52
  %55 = add i32 %54, %53
  %56 = tail call i32 @llvm.fshl.i32(i32 %54, i32 %54, i32 26)
  %57 = xor i32 %55, %56
  %58 = tail call i32 @llvm.fshl.i32(i32 %57, i32 %57, i32 6)
  %59 = add i32 %57, %55
  %60 = xor i32 %59, %58
  %61 = add i32 %13, 3
  %62 = add i32 %61, %60
  %63 = add i32 %59, %15
  %64 = tail call i32 @llvm.fshl.i32(i32 %62, i32 %62, i32 17)
  %65 = add i32 %63, %62
  %66 = xor i32 %65, %64
  %67 = tail call i32 @llvm.fshl.i32(i32 %66, i32 %66, i32 29)
  %68 = add i32 %66, %65
  %69 = xor i32 %68, %67
  %70 = add i32 %69, %68
  %71 = tail call i32 @llvm.fshl.i32(i32 %69, i32 %69, i32 16)
  %72 = xor i32 %70, %71
  %73 = tail call i32 @llvm.fshl.i32(i32 %72, i32 %72, i32 24)
  %74 = add i32 %72, %70
  %75 = xor i32 %74, %73
  %76 = add i32 %30, 4
  %77 = add i32 %76, %75
  %78 = add i32 %74, %13
  %79 = tail call i32 @llvm.fshl.i32(i32 %77, i32 %77, i32 13)
  %80 = add i32 %78, %77
  %81 = xor i32 %80, %79
  %82 = tail call i32 @llvm.fshl.i32(i32 %81, i32 %81, i32 15)
  %83 = add i32 %81, %80
  %84 = xor i32 %83, %82
  %85 = tail call i32 @llvm.fshl.i32(i32 %84, i32 %84, i32 26)
  %86 = add i32 %84, %83
  %87 = xor i32 %86, %85
  %88 = add i32 %86, %30
  %89 = add i32 %88, %87
  store i32 %89, ptr addrspace(1) %10, align 128
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define ptx_kernel void @loop_add_fusion(ptr noalias readonly align 16 captures(none) dereferenceable(4) %0, ptr noalias readonly align 16 captures(none) dereferenceable(4) %1, ptr noalias readonly align 16 captures(none) dereferenceable(4) %2, ptr noalias readonly align 16 captures(none) dereferenceable(4) %3, ptr noalias writeonly align 128 captures(none) dereferenceable(4) initializes((0, 4)) %4) local_unnamed_addr #0 {
  %6 = addrspacecast ptr %3 to ptr addrspace(1)
  %7 = addrspacecast ptr %2 to ptr addrspace(1)
  %8 = addrspacecast ptr %1 to ptr addrspace(1)
  %9 = addrspacecast ptr %0 to ptr addrspace(1)
  %10 = addrspacecast ptr %4 to ptr addrspace(1)
  %11 = load i32, ptr addrspace(1) %6, align 16, !invariant.load !2
  %12 = load i32, ptr addrspace(1) %7, align 16, !invariant.load !2
  %13 = load i32, ptr addrspace(1) %8, align 16, !invariant.load !2
  %14 = add i32 %13, %12
  %15 = load i32, ptr addrspace(1) %9, align 16, !invariant.load !2
  %16 = add i32 %15, %11
  %17 = tail call i32 @llvm.fshl.i32(i32 %14, i32 %14, i32 13)
  %18 = add i32 %16, %14
  %19 = xor i32 %18, %17
  %20 = tail call i32 @llvm.fshl.i32(i32 %19, i32 %19, i32 15)
  %21 = add i32 %19, %18
  %22 = xor i32 %21, %20
  %23 = add i32 %22, %21
  %24 = tail call i32 @llvm.fshl.i32(i32 %22, i32 %22, i32 26)
  %25 = xor i32 %23, %24
  %26 = tail call i32 @llvm.fshl.i32(i32 %25, i32 %25, i32 6)
  %27 = add i32 %25, %23
  %28 = xor i32 %27, %26
  %29 = xor i32 %13, %15
  %30 = xor i32 %29, 466688986
  %31 = add i32 %30, 1
  %32 = add i32 %31, %28
  %33 = add i32 %27, %13
  %34 = tail call i32 @llvm.fshl.i32(i32 %32, i32 %32, i32 17)
  %35 = add i32 %33, %32
  %36 = xor i32 %35, %34
  %37 = tail call i32 @llvm.fshl.i32(i32 %36, i32 %36, i32 29)
  %38 = add i32 %36, %35
  %39 = xor i32 %38, %37
  %40 = add i32 %39, %38
  %41 = tail call i32 @llvm.fshl.i32(i32 %39, i32 %39, i32 16)
  %42 = xor i32 %40, %41
  %43 = tail call i32 @llvm.fshl.i32(i32 %42, i32 %42, i32 24)
  %44 = add i32 %42, %40
  %45 = xor i32 %44, %43
  %46 = add i32 %15, 2
  %47 = add i32 %46, %45
  %48 = add i32 %44, %30
  %49 = tail call i32 @llvm.fshl.i32(i32 %47, i32 %47, i32 13)
  %50 = add i32 %48, %47
  %51 = xor i32 %50, %49
  %52 = tail call i32 @llvm.fshl.i32(i32 %51, i32 %51, i32 15)
  %53 = add i32 %51, %50
  %54 = xor i32 %53, %52
  %55 = add i32 %54, %53
  %56 = tail call i32 @llvm.fshl.i32(i32 %54, i32 %54, i32 26)
  %57 = xor i32 %55, %56
  %58 = tail call i32 @llvm.fshl.i32(i32 %57, i32 %57, i32 6)
  %59 = add i32 %57, %55
  %60 = xor i32 %59, %58
  %61 = add i32 %13, 3
  %62 = add i32 %61, %60
  %63 = add i32 %59, %15
  %64 = tail call i32 @llvm.fshl.i32(i32 %62, i32 %62, i32 17)
  %65 = add i32 %63, %62
  %66 = xor i32 %65, %64
  %67 = tail call i32 @llvm.fshl.i32(i32 %66, i32 %66, i32 29)
  %68 = add i32 %66, %65
  %69 = xor i32 %68, %67
  %70 = add i32 %69, %68
  %71 = tail call i32 @llvm.fshl.i32(i32 %69, i32 %69, i32 16)
  %72 = xor i32 %70, %71
  %73 = tail call i32 @llvm.fshl.i32(i32 %72, i32 %72, i32 24)
  %74 = add i32 %72, %70
  %75 = xor i32 %74, %73
  %76 = add i32 %30, 4
  %77 = add i32 %76, %75
  %78 = add i32 %74, %13
  %79 = tail call i32 @llvm.fshl.i32(i32 %77, i32 %77, i32 13)
  %80 = add i32 %78, %77
  %81 = xor i32 %80, %79
  %82 = tail call i32 @llvm.fshl.i32(i32 %81, i32 %81, i32 15)
  %83 = add i32 %81, %80
  %84 = xor i32 %83, %82
  %85 = tail call i32 @llvm.fshl.i32(i32 %84, i32 %84, i32 26)
  %86 = add i32 %84, %83
  %87 = xor i32 %86, %85
  %88 = add i32 %87, %86
  %89 = tail call i32 @llvm.fshl.i32(i32 %87, i32 %87, i32 6)
  %90 = xor i32 %88, %89
  %91 = add i32 %15, 5
  %92 = add i32 %91, %90
  store i32 %92, ptr addrspace(1) %10, align 128
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.fshl.i32(i32, i32, i32) #1

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) "nvvm.reqntid"="1,1,1" }
attributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 4, !"nvvm-reflect-ftz", i32 0}
!2 = !{}
